// Code generated by github.com/hasura/ndc-sdk-go/cmd/hasura-ndc-go, DO NOT EDIT.
package client

import (
	"encoding/json"
	"errors"
	"github.com/hasura/ndc-sdk-go/scalar"
	"github.com/hasura/ndc-sdk-go/utils"
	"slices"
)

// FromValue decodes values from map
func (j *LabelValuesParams) FromValue(input map[string]any) error {
	var err error
	j.LabelsParams, err = utils.DecodeObject[LabelsParams](input)
	if err != nil {
		return err
	}
	j.Name, err = utils.GetString(input, "name")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *LabelsParams) FromValue(input map[string]any) error {
	var err error
	j.End, err = utils.GetNullableDateTime(input, "end")
	if err != nil {
		return err
	}
	j.Query, err = utils.GetStringDefault(input, "query")
	if err != nil {
		return err
	}
	j.Since, err = utils.DecodeNullableObjectValue[scalar.Duration](input, "since")
	if err != nil {
		return err
	}
	j.Start, err = utils.GetNullableDateTime(input, "start")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *QueryParams) FromValue(input map[string]any) error {
	var err error
	j.Direction, err = utils.DecodeNullableObjectValue[QueryDirection](input, "direction")
	if err != nil {
		return err
	}
	j.Limit, err = utils.GetIntDefault[int](input, "limit")
	if err != nil {
		return err
	}
	j.Query, err = utils.GetString(input, "query")
	if err != nil {
		return err
	}
	j.Time, err = utils.GetNullableDateTime(input, "time")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *QueryRangeParams) FromValue(input map[string]any) error {
	var err error
	j.Direction, err = utils.DecodeNullableObjectValue[QueryDirection](input, "direction")
	if err != nil {
		return err
	}
	j.End, err = utils.GetNullableDateTime(input, "end")
	if err != nil {
		return err
	}
	j.Interval, err = utils.DecodeNullableObjectValue[scalar.Duration](input, "interval")
	if err != nil {
		return err
	}
	j.Limit, err = utils.GetIntDefault[int](input, "limit")
	if err != nil {
		return err
	}
	j.Query, err = utils.GetString(input, "query")
	if err != nil {
		return err
	}
	j.Since, err = utils.DecodeNullableObjectValue[scalar.Duration](input, "since")
	if err != nil {
		return err
	}
	j.Start, err = utils.GetNullableDateTime(input, "start")
	if err != nil {
		return err
	}
	j.Step, err = utils.DecodeNullableObjectValue[scalar.Duration](input, "step")
	if err != nil {
		return err
	}
	return nil
}

// ToMap encodes the struct to a value map
func (j LabelsParams) ToMap() map[string]any {
	r := make(map[string]any)
	r["end"] = j.End
	r["query"] = j.Query
	r["since"] = j.Since
	r["start"] = j.Start

	return r
}

// ToMap encodes the struct to a value map
func (j LogDeletionRequest) ToMap() map[string]any {
	r := make(map[string]any)
	r["end_time"] = j.EndTime
	r["query"] = j.Query
	r["start_time"] = j.StartTime
	r["status"] = j.Status

	return r
}

// ToMap encodes the struct to a value map
func (j LogLineInput) ToMap() map[string]any {
	r := make(map[string]any)
	r["line"] = j.Line
	r["structured_metadata"] = j.StructuredMetadata
	r["timestamp"] = j.Timestamp

	return r
}

// ToMap encodes the struct to a value map
func (j MatrixValue) ToMap() map[string]any {
	r := make(map[string]any)
	r["time"] = j.Time
	r["value"] = j.Value

	return r
}

// ToMap encodes the struct to a value map
func (j MatrixValues) ToMap() map[string]any {
	r := make(map[string]any)
	r["metric"] = j.Metric
	j_Values := make([]any, len(j.Values))
	for i, j_Values_v := range j.Values {
		j_Values[i] = j_Values_v
	}
	r["values"] = j_Values

	return r
}

// ToMap encodes the struct to a value map
func (j QueryData) ToMap() map[string]any {
	r := make(map[string]any)
	r["encodingFlags"] = j.EncodingFlags
	r["resultType"] = j.ResultType
	j_Vector := make([]any, len(j.Vector))
	for i, j_Vector_v := range j.Vector {
		j_Vector[i] = j_Vector_v
	}
	r["vector"] = j_Vector

	return r
}

// ToMap encodes the struct to a value map
func (j QueryRangeData) ToMap() map[string]any {
	r := make(map[string]any)
	r["encodingFlags"] = j.EncodingFlags
	j_Matrix := make([]any, len(j.Matrix))
	for i, j_Matrix_v := range j.Matrix {
		j_Matrix[i] = j_Matrix_v
	}
	r["matrix"] = j_Matrix
	r["resultType"] = j.ResultType
	j_Stream := make([]any, len(j.Stream))
	for i, j_Stream_v := range j.Stream {
		j_Stream[i] = j_Stream_v
	}
	r["stream"] = j_Stream

	return r
}

// ToMap encodes the struct to a value map
func (j StreamInput) ToMap() map[string]any {
	r := make(map[string]any)
	r["stream"] = j.Stream
	j_Values := make([]any, len(j.Values))
	for i, j_Values_v := range j.Values {
		j_Values[i] = j_Values_v
	}
	r["values"] = j_Values

	return r
}

// ToMap encodes the struct to a value map
func (j StreamValue) ToMap() map[string]any {
	r := make(map[string]any)
	r["time"] = j.Time
	r["value"] = j.Value

	return r
}

// ToMap encodes the struct to a value map
func (j StreamValues) ToMap() map[string]any {
	r := make(map[string]any)
	r["stream"] = j.Stream
	j_Values := make([]any, len(j.Values))
	for i, j_Values_v := range j.Values {
		j_Values[i] = j_Values_v
	}
	r["values"] = j_Values

	return r
}

// ToMap encodes the struct to a value map
func (j VectorValue) ToMap() map[string]any {
	r := make(map[string]any)
	r["metric"] = j.Metric
	r["time"] = j.Time
	r["value"] = j.Value

	return r
}

// ScalarName get the schema name of the scalar
func (j QueryDirection) ScalarName() string {
	return "QueryDirection"
}

const (
	QueryDirectionForward  QueryDirection = "forward"
	QueryDirectionBackward QueryDirection = "backward"
)

var enumValues_QueryDirection = []QueryDirection{QueryDirectionForward, QueryDirectionBackward}

// ParseQueryDirection parses a QueryDirection enum from string
func ParseQueryDirection(input string) (QueryDirection, error) {
	result := QueryDirection(input)
	if !slices.Contains(enumValues_QueryDirection, result) {
		return QueryDirection(""), errors.New("failed to parse QueryDirection, expect one of QueryDirectionForward, QueryDirectionBackward")
	}

	return result, nil
}

// IsValid checks if the value is invalid
func (j QueryDirection) IsValid() bool {
	return slices.Contains(enumValues_QueryDirection, j)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryDirection) UnmarshalJSON(b []byte) error {
	var rawValue string
	if err := json.Unmarshal(b, &rawValue); err != nil {
		return err
	}

	value, err := ParseQueryDirection(rawValue)
	if err != nil {
		return err
	}

	*j = value
	return nil
}

// FromValue decodes the scalar from an unknown value
func (s *QueryDirection) FromValue(value any) error {
	valueStr, err := utils.DecodeNullableString(value)
	if err != nil {
		return err
	}
	if valueStr == nil {
		return nil
	}
	result, err := ParseQueryDirection(*valueStr)
	if err != nil {
		return err
	}

	*s = result
	return nil
}
